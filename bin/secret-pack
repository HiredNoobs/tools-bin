#!/usr/bin/env python3
#
# Takes a list of files and converts to a dict.
#
# File names become keys and the contents of the file
# becomes the values. Where a binary file is found
# the contents are base64 encoded and ".base64" is
# appended to the key.
# Output is dumped to stdout as flat json.
#
# Usage:
# secret-pack <FILE> ... <FILE>

import argparse
import base64
import json
import os
from pathlib import Path
from typing import Tuple


def is_binary(data: bytes) -> bool:
    """
    Takes a bytes object and checks if it is binary.
    See: https://stackoverflow.com/a/7392391
    """
    textchars = bytearray({7, 8, 9, 10, 12, 13, 27} | set(range(0x20, 0x100)) - {0x7F})
    return any(byte not in textchars for byte in data)


def encode(path: str) -> Tuple[str, str]:
    key = os.path.basename(path)
    with open(path, "rb") as file:
        value = file.read()

    if is_binary(value):
        key = f"{key}.base64"
        value = base64.b64encode(value)

    try:
        return (key, value.decode("utf-8"))
    except UnicodeDecodeError as err:
        raise Exception(
            f"Couldn't decode {path}.\nThe most likely reason is the file was "
            "incorrectly assessed as to whether it is binary."
        ) from err


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Converts a list of files to a list of json objects."
    )
    parser.add_argument("files", nargs="+", type=Path, help="Path to files to pack.")
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    secret = [encode(file) for file in args.files]
    print(json.dumps(dict(secret)))


if __name__ == "__main__":
    main()
