#!/usr/bin/env bash

THIS=$(realpath "$0")
HERE=$(dirname "$THIS")

source $HERE/lib/logging.sh
source $HERE/lib/utils.sh
source $HERE/lib/env

# -----------------------------------------------------
# Helper functions
# -----------------------------------------------------

function check_env {
  local contexts current_stack

  if [[ ! -v DEPLOYMENT ]]; then
    log_error "DEPLOYMENT is unset - source a stack.env file"
    exit 1
  fi

  contexts=$(docker context ls --format '{{ .Name }}' | grep -v 'default')
  if ! printf '%s\n' "$contexts" | grep -Fxq -- "$CONTEXT"; then
    log_error "Context, $CONTEXT, not in locally defined contexts."
    exit 1
  fi

  current_stack=$(basename "$PWD")
  if [ "stack-$STACK_BASE" != "$current_stack" ]; then
    log_error "Sourced stack ($STACK_BASE) doesn't match the current stack."
    exit 1
  fi

  if ! env_matches_file "$ENVIRONMENT_BASE/stack.env"; then
    log_warning "Current env doesn't match the stack.env"
  fi
}

function env_matches_file {
  local file="$1"
  local line key value

  while IFS= read -r line; do
    # Stripping comments, exports, and whitespace
    line="${line%%#*}"
    line="${line#export }"
    line="$(echo "$line" | xargs)"

    [[ -z "$line" ]] && continue

    key="${line%%=*}"
    value="${line#*=}"

    value="${value%\"}"; value="${value#\"}"
    value="${value%\'}"; value="${value#\'}"

    [[ "${!key}" != "$value" ]] && return 1
  done < "$file"

  return 0
}

function discover_stack_context {
  export DOCKER_CONTEXT="$CONTEXT"
  if [ -f "${SECRETS}/secrets.env" ]; then
    source "${SECRETS}/secrets.env"
  fi

  if [[ -v DOMAIN ]]; then
    eval "$(docker node ls -q | xargs docker node inspect | export-roles "$STACK" --domain "$DOMAIN")"
  else
    eval "$(docker node ls -q | xargs docker node inspect | export-roles "$STACK")"
  fi

  stack_discover
}

# -----------------------------------------------------
# Run functions
# -----------------------------------------------------

function run_help {
  local deployment_commands term_width help_func help_output combined_output

  if [ -f "$HERE/deployment_help" ]; then
    source "$HERE/deployment_help"
  fi

  if [ -f "$STACK_BASE/stack_help" ]; then
    source "$STACK_BASE/stack_help"
  fi

  deployment_commands=$(declare -F | awk '/ command_/ && (!/_help$/ || /command_help$/) { gsub("command_", "", $3); print $3 }')

  log_info "Deployment commands:"
  term_width=$(tput cols)

  for func in $deployment_commands; do
    log_info "* $func"
    help_func="command_${func}_help"
    if declare -F "$help_func" > /dev/null; then
      help_output=$("$help_func")
      combined_output=$(echo "$help_output" | awk 'BEGIN { ORS=" " } { if (NF == 0) { print "\n" } else { print } }' | sed 's/$ //' | fold -s -w "$term_width")
      log_info "$combined_output" | sed 's/^/    /'
    fi
  done
}

function run_pull_secrets {
  local vault_env="$1"
  local vault_secret="$2"
  mkdir -p "$SECRETS"
  vault read "lab/${vault_env}/${vault_secret}" -format=json | jq .data | secret-unpack "$SECRETS"
}

function run_push_secrets {
  local vault_env="$1"
  local vault_secret="$2"
  if [ "$(ls -A $SECRETS)" ]; then
    secret-pack ${SECRETS}/* | vault write "lab/${vault_env}/${vault_secret}" -
  else
    log_info "There are no local secrets to push."
    log_info "If you intended to delete the $vault_secret secret please use the UI."
  fi
}

function run_diff_secrets {
  local vault_env="$1"
  local vault_secret="$2"
  vault read "lab/${vault_env}/${vault_secret}" -format=json | jq .data | secret-diff "${SECRETS}"
}

function run_tools {
  stack_tools $@
}

function run_env {
  echo "DEPLOYMENT  = $DEPLOYMENT"
  echo "STACK       = $STACK"
  echo "ENVIRONMENT = $ENVIRONMENT"
  echo "CONTEXT     = $CONTEXT"
  echo "CONFIGS     = $CONFIGS"
  echo "SECRETS     = $SECRETS"
  stack_env
}

function run_deploy {
  stack_deploy
}

function run_status {
  docker stack ps "$STACK"
}

function run_clean {
  log_info "Removing $STACK..."
  docker stack rm "$STACK" --detach=false
}

# -----------------------------------------------------
# Commands
# -----------------------------------------------------

function command_help {
  run_help
}

function command_tools {
  if [ ! -d "$STACK_PATH/tools" ]; then
    log_info "No tools for current deployment."
    exit 1
  fi

  discover_stack_context
  run_tools $@
}

function command_pull_secrets {
  if [[ -n "$1" && -n "$2" ]]; then
    run_pull_secrets "$1" "$2"
  else
    run_pull_secrets "$ENVIRONMENT" "$STACK"
  fi
}

function command_push_secrets {
  if [[ -n "$1" && -n "$2" ]]; then
    run_pull_secrets "$1" "$2"
  else
    run_push_secrets "$ENVIRONMENT" "$STACK"
  fi
}

function command_diff_secrets {
  if [[ -n "$1" && -n "$2" ]]; then
    run_pull_secrets "$1" "$2"
  else
    run_diff_secrets "$ENVIRONMENT" "$STACK"
  fi
}

# Discovers and prints out the env.
#
# If another command is passed as an arg rather than
# printing the env it will run that command.
# The main purpose of this is for running `env env`
# to see the "discovered" environment variables.
function command_env {
  discover_stack_context
  if [ -z "$1" ]; then
    run_env
  else
    $@
    local error=$?
    exit $error
  fi
}

function command_deploy {
  discover_stack_context
  run_deploy
}

function command_status {
  discover_stack_context
  run_status
}

function command_clean {
  discover_stack_context
  run_clean
}

# -----------------------------------------------------
# Main
# -----------------------------------------------------

check_env
source "./stack"
stack_check_env

ARG=${1:-help}
CMD="command_$ARG"
shift

if declare -F "$CMD" >/dev/null; then
  $CMD "$@"
else
  log_error "$ARG is not a valid command."
fi
